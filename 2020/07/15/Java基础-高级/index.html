<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java 基础 | PMSRookie</title><meta name="description" content="简单的复习，可能有许多的没写完整，后期看情况补充"><meta name="keywords" content="java"><meta name="author" content="PMSRookie"><meta name="copyright" content="PMSRookie"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://pmsrookie.github.io/2020/07/15/Java%E5%9F%BA%E7%A1%80-%E9%AB%98%E7%BA%A7/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Java 基础"><meta property="og:url" content="https://pmsrookie.github.io/2020/07/15/Java%E5%9F%BA%E7%A1%80-%E9%AB%98%E7%BA%A7/"><meta property="og:site_name" content="PMSRookie"><meta property="og:description" content="简单的复习，可能有许多的没写完整，后期看情况补充"><meta property="og:image" content="https://pmsrookie.github.io/img/cover-img.jpg"><meta property="article:published_time" content="2020-07-15T06:10:10.000Z"><meta property="article:modified_time" content="2020-08-30T02:35:52.152Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="计算机网络基础" href="https://pmsrookie.github.io/2020/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"><link rel="next" title="hexo主题修改" href="https://pmsrookie.github.io/2020/06/29/hexo%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="PMSRookie" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-JAVA-介绍、安装、配置、使用"><span class="toc-number">1.</span> <span class="toc-text">1. JAVA 介绍、安装、配置、使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-java虚拟机-JVM"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 java虚拟机 (JVM)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-JRE-和-JDK"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 JRE 和 JDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-JDK下载安装以及环境配置"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 JDK下载安装以及环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#下载安装"><span class="toc-number">1.3.1.</span> <span class="toc-text">下载安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#环境配置"><span class="toc-number">1.3.2.</span> <span class="toc-text">环境配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Hello-World"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 Hello World</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-基础语法"><span class="toc-number">2.</span> <span class="toc-text">2 基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-关键字"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-标识符"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-常量"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-数据类型"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-变量"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-数据类型转换"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 数据类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#自动转换"><span class="toc-number">2.6.1.</span> <span class="toc-text">自动转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#强制转换"><span class="toc-number">2.6.2.</span> <span class="toc-text">强制转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-运算符"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-方法"><span class="toc-number">2.8.</span> <span class="toc-text">2.8 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#有参方法"><span class="toc-number">2.8.1.</span> <span class="toc-text">有参方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无参方法"><span class="toc-number">2.8.2.</span> <span class="toc-text">无参方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有返回方法"><span class="toc-number">2.8.3.</span> <span class="toc-text">有返回方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无返回方法"><span class="toc-number">2.8.4.</span> <span class="toc-text">无返回方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法重载"><span class="toc-number">2.8.5.</span> <span class="toc-text">方法重载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-流程"><span class="toc-number">2.9.</span> <span class="toc-text">2.9 流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-数组"><span class="toc-number">2.10.</span> <span class="toc-text">2.10 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-number">2.10.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-java的内存划分"><span class="toc-number">2.11.</span> <span class="toc-text">2.11 java的内存划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-面对对象"><span class="toc-number">2.12.</span> <span class="toc-text">2.12 面对对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-1-面对对象-封装性"><span class="toc-number">2.12.1.</span> <span class="toc-text">2.12.1 面对对象-封装性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#封装性的体现"><span class="toc-number">2.12.1.1.</span> <span class="toc-text">封装性的体现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-2-面对对象-继承性-extends"><span class="toc-number">2.12.2.</span> <span class="toc-text">2.12.2 面对对象-继承性 ( extends )</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#继承特性"><span class="toc-number">2.12.2.1.</span> <span class="toc-text">继承特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法重写-Override"><span class="toc-number">2.12.2.2.</span> <span class="toc-text">方法重写 ( @Override )</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-12-3-面对对象-多态性"><span class="toc-number">2.12.3.</span> <span class="toc-text">2.12.3 面对对象-多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多态性的体现"><span class="toc-number">2.12.3.1.</span> <span class="toc-text">多态性的体现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向上转型"><span class="toc-number">2.12.3.2.</span> <span class="toc-text">向上转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向下转型"><span class="toc-number">2.12.3.3.</span> <span class="toc-text">向下转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注意"><span class="toc-number">2.12.3.4.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-13-字符串-String"><span class="toc-number">2.13.</span> <span class="toc-text">2.13 字符串 ( String )</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串底层存储"><span class="toc-number">2.13.1.</span> <span class="toc-text">字符串底层存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串常用的-API"><span class="toc-number">2.13.2.</span> <span class="toc-text">字符串常用的 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串常量池"><span class="toc-number">2.13.3.</span> <span class="toc-text">字符串常量池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-14-静态代码块"><span class="toc-number">2.14.</span> <span class="toc-text">2.14 静态代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注意-1"><span class="toc-number">2.14.1.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-15-抽象类和抽象方法-abstract"><span class="toc-number">2.15.</span> <span class="toc-text">2.15 抽象类和抽象方法 ( abstract )</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#注意-2"><span class="toc-number">2.15.0.1.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-16-接口-interface"><span class="toc-number">2.16.</span> <span class="toc-text">2.16 接口 ( interface )</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接口可定义内容"><span class="toc-number">2.16.1.</span> <span class="toc-text">接口可定义内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口使用-implements"><span class="toc-number">2.16.2.</span> <span class="toc-text">接口使用 ( implements )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意-3"><span class="toc-number">2.16.3.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-17-内部类"><span class="toc-number">2.17.</span> <span class="toc-text">2.17 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#成员内部类"><span class="toc-number">2.17.1.</span> <span class="toc-text">成员内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#注意：内用外，随意用。外用内，需要内部类对象。"><span class="toc-number">2.17.1.1.</span> <span class="toc-text">注意：内用外，随意用。外用内，需要内部类对象。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内部类可用权限修饰符：public-protected-default-private"><span class="toc-number">2.17.1.2.</span> <span class="toc-text">内部类可用权限修饰符：public &#x2F; protected &#x2F; (default) &#x2F; private</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#外部类可用权限修饰符：public-default"><span class="toc-number">2.17.1.3.</span> <span class="toc-text">外部类可用权限修饰符：public &#x2F; (default)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部内部类"><span class="toc-number">2.17.2.</span> <span class="toc-text">局部内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#注意：只能定义方法使用"><span class="toc-number">2.17.2.1.</span> <span class="toc-text">注意：只能定义方法使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名内部类"><span class="toc-number">2.17.3.</span> <span class="toc-text">匿名内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用场景：只需使用一次该接口的情况下，就可以使用匿名内部类"><span class="toc-number">2.17.3.1.</span> <span class="toc-text">使用场景：只需使用一次该接口的情况下，就可以使用匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包装类"><span class="toc-number">2.17.4.</span> <span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#装箱"><span class="toc-number">2.17.4.1.</span> <span class="toc-text">装箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#拆箱"><span class="toc-number">2.17.4.2.</span> <span class="toc-text">拆箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自动装箱和自动拆箱"><span class="toc-number">2.17.4.3.</span> <span class="toc-text">自动装箱和自动拆箱</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-JAVA-常见类"><span class="toc-number">3.</span> <span class="toc-text">3 JAVA 常见类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Date-日期类"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 Date (日期类)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-日期格式转换类"><span class="toc-number">3.2.</span> <span class="toc-text">3.2  (日期格式转换类)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Calendar-日历类"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 Calendar (日历类)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注意：Calendar类是一个抽象类"><span class="toc-number">3.3.1.</span> <span class="toc-text">注意：Calendar类是一个抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用成员方法"><span class="toc-number">3.3.2.</span> <span class="toc-text">常用成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-System"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常用成员方法-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">常用成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-StringBuilder-字符串缓冲区"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 StringBuilder (字符串缓冲区)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常用成员方法-2"><span class="toc-number">3.5.1.</span> <span class="toc-text">常用成员方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-JAVA-基础"><span class="toc-number">4.</span> <span class="toc-text">4 JAVA 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-集合"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-Collection-接口"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1 Collection 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#成员方法"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-List-接口"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2 List 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常用成员方法-3"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">常用成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-Set-接口"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3 Set 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-ArrayList"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.1.4 ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点：底层数组实现，查询快，增删慢"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">特点：底层数组实现，查询快，增删慢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用成员方法-4"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">常用成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-LinkedList"><span class="toc-number">4.1.5.</span> <span class="toc-text">4.1.5 LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点：底层链表实现，查询慢，增删快"><span class="toc-number">4.1.5.1.</span> <span class="toc-text">特点：底层链表实现，查询慢，增删快</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注意：LinkedList-不可以使用多态写法"><span class="toc-number">4.1.5.2.</span> <span class="toc-text">注意：LinkedList 不可以使用多态写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用成员方法-5"><span class="toc-number">4.1.5.3.</span> <span class="toc-text">常用成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-6-HashSet"><span class="toc-number">4.1.6.</span> <span class="toc-text">4.1.6 HashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点：底层哈希表-红黑树-实现，无索引，存储元素不会重复，存取无序"><span class="toc-number">4.1.6.1.</span> <span class="toc-text">特点：底层哈希表+(红黑树)实现，无索引，存储元素不会重复，存取无序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet-存储元素不会重复情况"><span class="toc-number">4.1.6.2.</span> <span class="toc-text">HashSet 存储元素不会重复情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet-存储自定义类"><span class="toc-number">4.1.6.3.</span> <span class="toc-text">HashSet 存储自定义类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-6-LinkedHashSet"><span class="toc-number">4.1.7.</span> <span class="toc-text">4.1.6 LinkedHashSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点：底层哈希表-链表（记住元素顺序）实现，无索引，不可存储重复元素，可以保证存取顺序"><span class="toc-number">4.1.7.1.</span> <span class="toc-text">特点：底层哈希表+链表（记住元素顺序）实现，无索引，不可存储重复元素，可以保证存取顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-6-TreeSet"><span class="toc-number">4.1.8.</span> <span class="toc-text">4.1.6 TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点：底层二叉树实现，一般用于排序"><span class="toc-number">4.1.8.1.</span> <span class="toc-text">特点：底层二叉树实现，一般用于排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-7-Collections-集合工具类"><span class="toc-number">4.1.9.</span> <span class="toc-text">4.1.7 Collections ( 集合工具类 )</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#成员方法-1"><span class="toc-number">4.1.9.1.</span> <span class="toc-text">成员方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-扩展-——-数据结构"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 扩展 —— 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-栈-Stack"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 栈 ( Stack )</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特性"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-队列"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特性-1"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-链表"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特性-2"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单向链表"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">单向链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双向链表"><span class="toc-number">4.2.3.3.</span> <span class="toc-text">双向链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-红黑树"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4 红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特性-3"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-哈希表"><span class="toc-number">4.2.5.</span> <span class="toc-text">4.2.5 哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#哈希值"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">哈希值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK-版本哈希表情况"><span class="toc-number">4.2.5.2.</span> <span class="toc-text">JDK 版本哈希表情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-6-递归"><span class="toc-number">4.2.6.</span> <span class="toc-text">4.2.6 递归</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念"><span class="toc-number">4.2.6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分类"><span class="toc-number">4.2.6.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注意："><span class="toc-number">4.2.6.3.</span> <span class="toc-text">注意：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Iterator-接口-迭代器"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 Iterator 接口 ( 迭代器 )</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代概念"><span class="toc-number">4.3.1.</span> <span class="toc-text">迭代概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成员方法-2"><span class="toc-number">4.3.2.</span> <span class="toc-text">成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-泛型"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在不知道该用什么数据类型时可以使用泛型"><span class="toc-number">4.4.1.</span> <span class="toc-text">在不知道该用什么数据类型时可以使用泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型通配符"><span class="toc-number">4.4.2.</span> <span class="toc-text">泛型通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型的上限限定"><span class="toc-number">4.4.3.</span> <span class="toc-text">泛型的上限限定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型的下限限定"><span class="toc-number">4.4.4.</span> <span class="toc-text">泛型的下限限定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-可变参数"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 可变参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#规则"><span class="toc-number">4.5.1.</span> <span class="toc-text">规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-Map-lt-K-V-gt-接口"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 Map&lt;K, V&gt; 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点-1"><span class="toc-number">4.6.0.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用成员方法-6"><span class="toc-number">4.6.0.2.</span> <span class="toc-text">常用成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">4.6.1.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点-2"><span class="toc-number">4.6.1.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap-存储自定义类键-key-值"><span class="toc-number">4.6.1.2.</span> <span class="toc-text">HashMap 存储自定义类键(key)值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">4.6.2.</span> <span class="toc-text">LinkedHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点-3"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashtable-lt-K-V-gt"><span class="toc-number">4.6.3.</span> <span class="toc-text">Hashtable&lt;K, V&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点-4"><span class="toc-number">4.6.3.1.</span> <span class="toc-text">特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Entry-lt-K-V-gt-键-key-值-value-对对象"><span class="toc-number">4.6.4.</span> <span class="toc-text">Entry&lt;K, V&gt; ( 键(key)值(value)对对象 )</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点-5"><span class="toc-number">4.6.4.1.</span> <span class="toc-text">特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-异常-Exception"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 异常 ( Exception )</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异常处理"><span class="toc-number">4.7.1.</span> <span class="toc-text">异常处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-多线程"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#进程"><span class="toc-number">4.8.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程"><span class="toc-number">4.8.2.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread-与-Runnable-的区别"><span class="toc-number">4.8.2.1.</span> <span class="toc-text">Thread 与 Runnable 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用成员方法-7"><span class="toc-number">4.8.2.2.</span> <span class="toc-text">常用成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并发：指两个或多个事件在同一【时间】进行。交替进行"><span class="toc-number">4.8.2.3.</span> <span class="toc-text">并发：指两个或多个事件在同一【时间】进行。交替进行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并行：指两个或多个事件在同一【时刻】进行。同时进行"><span class="toc-number">4.8.2.4.</span> <span class="toc-text">并行：指两个或多个事件在同一【时刻】进行。同时进行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程安全"><span class="toc-number">4.8.2.5.</span> <span class="toc-text">线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解决线程安全"><span class="toc-number">4.8.2.6.</span> <span class="toc-text">解决线程安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程状态"><span class="toc-number">4.8.2.7.</span> <span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程间的通信"><span class="toc-number">4.8.2.8.</span> <span class="toc-text">线程间的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#注意：wait-notify-notifyAll-必须得用【锁对象】调用，且只能在同一同步代码块或者方法当中。"><span class="toc-number">4.8.2.8.1.</span> <span class="toc-text">注意：wait() | notify() | notifyAll() 必须得用【锁对象】调用，且只能在同一同步代码块或者方法当中。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程池"><span class="toc-number">4.8.2.9.</span> <span class="toc-text">线程池</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-Lambda-表达式"><span class="toc-number">4.9.</span> <span class="toc-text">4.9 Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数式编程"><span class="toc-number">4.9.1.</span> <span class="toc-text">函数式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可省略内容及要求"><span class="toc-number">4.9.2.</span> <span class="toc-text">可省略内容及要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#格式-：-由三部分组成"><span class="toc-number">4.9.3.</span> <span class="toc-text">格式 ： 由三部分组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法引用"><span class="toc-number">4.9.4.</span> <span class="toc-text">方法引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-IO"><span class="toc-number">4.10.</span> <span class="toc-text">4.10 IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念-1"><span class="toc-number">4.10.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-1-File-类"><span class="toc-number">4.10.2.</span> <span class="toc-text">4.10.1 File 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常用静态成员变量"><span class="toc-number">4.10.2.1.</span> <span class="toc-text">常用静态成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常用成员方法-8"><span class="toc-number">4.10.2.2.</span> <span class="toc-text">常用成员方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文件过滤器"><span class="toc-number">4.10.2.3.</span> <span class="toc-text">文件过滤器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-2-字节流"><span class="toc-number">4.10.3.</span> <span class="toc-text">4.10.2 字节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-3-字符流"><span class="toc-number">4.10.4.</span> <span class="toc-text">4.10.3 字符流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-11-Properties-集合"><span class="toc-number">4.11.</span> <span class="toc-text">4.11 Properties 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#成员方法-3"><span class="toc-number">4.11.1.</span> <span class="toc-text">成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-12-缓存流"><span class="toc-number">4.12.</span> <span class="toc-text">4.12 缓存流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-number">4.12.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类"><span class="toc-number">4.12.2.</span> <span class="toc-text">类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-13-转换流"><span class="toc-number">4.13.</span> <span class="toc-text">4.13 转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编码：字符-–-gt-字节"><span class="toc-number">4.13.1.</span> <span class="toc-text">编码：字符 –&gt; 字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解码：字节-–-gt-字符"><span class="toc-number">4.13.2.</span> <span class="toc-text">解码：字节 –&gt; 字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类-1"><span class="toc-number">4.13.3.</span> <span class="toc-text">类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-14-序列化-反序列化"><span class="toc-number">4.14.</span> <span class="toc-text">4.14 序列化&#x2F;反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transient-关键字-瞬态关键字"><span class="toc-number">4.14.1.</span> <span class="toc-text">transient 关键字 : 瞬态关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-14-打印流"><span class="toc-number">4.15.</span> <span class="toc-text">4.14 打印流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PrintStream"><span class="toc-number">4.15.1.</span> <span class="toc-text">PrintStream</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-15-Stream-流"><span class="toc-number">4.16.</span> <span class="toc-text">4.15 Stream 流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注意-4"><span class="toc-number">4.16.1.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用方法"><span class="toc-number">4.16.2.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-16-测试"><span class="toc-number">4.17.</span> <span class="toc-text">4.16 测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-16-1-单元测试-Junit"><span class="toc-number">4.17.1.</span> <span class="toc-text">4.16.1 单元测试 Junit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#注解"><span class="toc-number">4.17.1.1.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#断言-Assert"><span class="toc-number">4.17.1.2.</span> <span class="toc-text">断言 Assert</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-17-反射"><span class="toc-number">4.18.</span> <span class="toc-text">4.17 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概念：将类的各个组成部分封装成其他对象，这就是反射机制。"><span class="toc-number">4.18.0.1.</span> <span class="toc-text">概念：将类的各个组成部分封装成其他对象，这就是反射机制。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-对象"><span class="toc-number">4.18.1.</span> <span class="toc-text">Class 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常用成员方法-9"><span class="toc-number">4.18.1.1.</span> <span class="toc-text">常用成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Field-对象-成员变量"><span class="toc-number">4.18.2.</span> <span class="toc-text">Field 对象 (成员变量)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常用成员方法-10"><span class="toc-number">4.18.2.1.</span> <span class="toc-text">常用成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructor-对象-构造方法"><span class="toc-number">4.18.3.</span> <span class="toc-text">Constructor 对象 (构造方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常用成员方法-11"><span class="toc-number">4.18.3.1.</span> <span class="toc-text">常用成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-对象-成员方法"><span class="toc-number">4.18.4.</span> <span class="toc-text">Method 对象 (成员方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常用成员方法-12"><span class="toc-number">4.18.4.1.</span> <span class="toc-text">常用成员方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-18-注解"><span class="toc-number">4.19.</span> <span class="toc-text">4.18 注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4"><span class="toc-number">4.19.1.</span> <span class="toc-text">4</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover-img.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">PMSRookie</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Java 基础</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-15 14:10:10"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-15</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-30 10:35:52"><i class="fas fa-history fa-fw"></i> 更新于 2020-08-30</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="1-JAVA-介绍、安装、配置、使用"><a href="#1-JAVA-介绍、安装、配置、使用" class="headerlink" title="1. JAVA 介绍、安装、配置、使用"></a>1. JAVA 介绍、安装、配置、使用</h1><h2 id="1-1-java虚拟机-JVM"><a href="#1-1-java虚拟机-JVM" class="headerlink" title="1.1 java虚拟机 (JVM)"></a>1.1 java虚拟机 (JVM)</h2><h2 id="1-2-JRE-和-JDK"><a href="#1-2-JRE-和-JDK" class="headerlink" title="1.2 JRE 和 JDK"></a>1.2 JRE 和 JDK</h2><ul>
<li><strong>JRE</strong>（）</li>
</ul>
<h2 id="1-3-JDK下载安装以及环境配置"><a href="#1-3-JDK下载安装以及环境配置" class="headerlink" title="1.3 JDK下载安装以及环境配置"></a>1.3 JDK下载安装以及环境配置</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>官方下载网址 <a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-downloads.html</a></p>
<p>找到自己相要的版本</p>
<p><img src= "/img/loading.gif" data-src="/images/Java%E5%9F%BA%E7%A1%80-%E9%AB%98%E7%BA%A7/download.JPG" alt="下载"></p>
<p>找到与自己操作系统相符的版本</p>
<p><img src= "/img/loading.gif" data-src="/images/Java%E5%9F%BA%E7%A1%80-%E9%AB%98%E7%BA%A7/download1.JPG" alt="下载"></p>
<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><h2 id="1-4-Hello-World"><a href="#1-4-Hello-World" class="headerlink" title="1.4 Hello World"></a>1.4 Hello World</h2><p>打开记事本并命名为 <code>helloworld.java</code> ，敲入代码</p>
<pre><code>// helloworld (必须和文件名一致)
public class helloworld {
    public static void main (String[] args) {
        System.out.println(&quot;Hello World!&quot;);
    }
}</code></pre><h1 id="2-基础语法"><a href="#2-基础语法" class="headerlink" title="2 基础语法"></a>2 基础语法</h1><h2 id="2-1-关键字"><a href="#2-1-关键字" class="headerlink" title="2.1 关键字"></a>2.1 关键字</h2><ul>
<li>概念：</li>
<li>特征：</li>
<li>权限修饰符关键字<ul>
<li>public</li>
<li>protected</li>
<li>(default)</li>
<li>private</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>(default)</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>同一个包</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>不同包是子类</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
<tr>
<td>不同包非子类</td>
<td>yes</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
</tbody></table>
<ul>
<li>this 关键字<ul>
<li>调用该对象的成员变量以及成员方法</li>
</ul>
</li>
<li>super 关键字<ul>
<li>调用继承的父类的成员变量以及成员方法</li>
</ul>
</li>
<li>abstract 关键字<ul>
<li>定义抽象类或者抽象方法的修饰词</li>
</ul>
</li>
<li>static 关键字</li>
<li>final 关键字<ul>
<li>用 final 关键字修饰说明不可被修改</li>
<li>修饰引用类型，地址不可改变，但值可以改变</li>
</ul>
</li>
<li>instanceof 关键字<ul>
<li>判断父类引用是否本来为某子类</li>
<li>格式：<code>父类对象 instanceof 子类名</code></li>
</ul>
</li>
<li>native 关键字<ul>
<li>表示该方法调用的是本地操作系统的方法</li>
</ul>
</li>
<li>throw/throws 关键字<ul>
<li><code>throw</code> 抛出指定异常</li>
<li><code>throws</code> 声明异常</li>
<li><code>throw new 异常对象();</code></li>
<li><code>throws 异常类命1, 异常类命2....</code></li>
</ul>
</li>
</ul>
<h2 id="2-2-标识符"><a href="#2-2-标识符" class="headerlink" title="2.2 标识符"></a>2.2 标识符</h2><ul>
<li>概念：自定义的内容，例如类名、方法名以及变量名</li>
<li>命名规则：<ul>
<li>标识符可包含：英文字母（26个，区分大小写）、0-9数字、$ 和 _</li>
<li>不能以数字开头</li>
<li>不能使用关键字</li>
</ul>
</li>
<li>命名规范：<ul>
<li>类命名规范：首字母大写，后面单词首字母都得大写</li>
<li>变量命名规范：首字母小写，后面单词首字母大写</li>
<li>方法名命名规范：首字母小写，后面单词首字母大写</li>
</ul>
</li>
</ul>
<h2 id="2-3-常量"><a href="#2-3-常量" class="headerlink" title="2.3 常量"></a>2.3 常量</h2><ul>
<li>概念：程序运行期间，固定不变的量</li>
<li>常量分类：<ul>
<li>字符串常量：”asd”、 “2s2e3”、 “123”</li>
<li>整型常量：2 、 34 、 43 、 -324</li>
<li>浮点型常量：2.3 、  42.123 、  34.65000</li>
<li>字符常量：’a’ 、  ‘A’ 、 ‘9’</li>
<li>布尔常量: true  、  false</li>
<li>空常量：null</li>
</ul>
</li>
</ul>
<h2 id="2-4-数据类型"><a href="#2-4-数据类型" class="headerlink" title="2.4 数据类型"></a>2.4 数据类型</h2><ul>
<li>基本数据类型：<ul>
<li>整数、浮点数、字符、布尔</li>
</ul>
</li>
<li>引用数据类型：<ul>
<li>字符串、数组、类、接口</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>关键字</th>
<th>内存占用</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>字节型</td>
<td>byte</td>
<td>1个字节</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td>2个字节</td>
<td>-32768 ~ 32767</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
<td>4个字节</td>
<td>-2<sup>31</sup> ~ 2<sup>31</sup></td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>8个字节</td>
<td>-2<sup>63</sup> ~ 2<sup>63</sup></td>
</tr>
<tr>
<td>单精浮点数</td>
<td>float</td>
<td>4个字节</td>
<td>1.4013E ~ 3.4028E+38</td>
</tr>
<tr>
<td>双精浮点数</td>
<td>double</td>
<td>8个字节</td>
<td>4.9E-324 ~ 1.7977E+308</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>2个字节</td>
<td>0 ~ 65535</td>
</tr>
<tr>
<td>布尔型</td>
<td>Boolean</td>
<td>1个字节</td>
<td>true false</td>
</tr>
</tbody></table>
<p><strong>单精浮点数值后加个 F ,例如：float num = 2.21F;</strong></p>
<p><strong>长整型值后加个 L ,例如：long num = 2242342L;</strong></p>
<h2 id="2-5-变量"><a href="#2-5-变量" class="headerlink" title="2.5 变量"></a>2.5 变量</h2><ul>
<li>概念：程序运行期间，内容可发生变化的值</li>
<li>创建变量：数据类型 变量名; 例如： <code>int num;</code></li>
<li>变量赋值：变量名 = 值; 例如： <code>num = 10;</code></li>
<li>成员变量：具有默认值</li>
<li>局部变量：</li>
<li>注意：<ul>
<li>变量名不能重复</li>
<li>不能超出数据类型的取值范围</li>
<li>不能超出作用域范围</li>
</ul>
</li>
</ul>
<h2 id="2-6-数据类型转换"><a href="#2-6-数据类型转换" class="headerlink" title="2.6 数据类型转换"></a>2.6 数据类型转换</h2><h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><ul>
<li>特点：代码不需要特殊处理，自动完成</li>
<li>规则：数据范围从小到大 （ 大 = 小 ）</li>
</ul>
<h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><ul>
<li>特点：代码需要特殊处理，不能自动完成</li>
<li>格式：范围小的类型 变量名 = (范围小的类型) 范围大的数据</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>强制转换可能会发生精度损失，数据溢出</li>
<li>byte/short/char都可以发生数学运算。 （ + - * / ）<ul>
<li>byte + byte 会被转化为 int + int 进行运算</li>
<li>short + byte 会被转化为 int + int 进行运算</li>
<li>即 byte 与 short需要运算时都会被转换成 int 进行运算</li>
<li>char 转换成 ASCII 码 对应得 int 运算</li>
</ul>
</li>
</ul>
<h2 id="2-7-运算符"><a href="#2-7-运算符" class="headerlink" title="2.7 运算符"></a>2.7 运算符</h2><ul>
<li>四则运算<ul>
<li>+ 加<ul>
<li>对于 char 类型来说，会将 char 转换成 int 在进行运算</li>
<li>对于 String 类型来说，加法为字符串的连接操作</li>
</ul>
</li>
<li>- 减</li>
<li>* 乘</li>
<li>/ 除</li>
</ul>
</li>
<li>取模（取余）<ul>
<li>% （取余）</li>
</ul>
</li>
<li>自增自减<ul>
<li>变量名++; 先取值再进行自增</li>
<li>++变量名; 先自增再取值</li>
<li>变量名–; 先取值再进行自减</li>
<li>–变量名; 先自减再取值</li>
</ul>
</li>
<li>赋值运算符<ul>
<li>=</li>
<li>+= 例如：a += 1; 相当于：a = a + 1;</li>
<li>-= 例如：a -= 1; 相当于：a = a - 1;</li>
<li>*= 例如：a *= 1; 相当于：a = a * 1;</li>
<li>/= 例如：a /= 1; 相当于：a = a / 1;</li>
<li>%= 例如：a %= 1; 相当于：a = a % 1;</li>
</ul>
</li>
<li>比较运算符<ul>
<li>== 相等比较</li>
<li>&lt; 小于比较</li>
<li>&gt; 大于比较</li>
<li>&lt;= 小于等于比较</li>
<li>&gt;= 大于等于比较</li>
<li>!= 不等比较</li>
</ul>
</li>
<li>逻辑运算符<ul>
<li>&amp;&amp; 与（并且）全为 true 才为 true 否则为 false</li>
<li>|| 或（或者）只要有一个为 true 则为 true 否则为 false</li>
<li>! 非（取反）如果为 true 则为 false，反之若为 fasle 则为 true</li>
</ul>
</li>
<li>三元运算符<ul>
<li>格式：数据类型 变量名 = 条件判断 ？ 表达式A : 表达式B</li>
<li>流程：若成立则将表达式A赋予变量，若不成立则将表达式B赋予变量</li>
</ul>
</li>
</ul>
<h2 id="2-8-方法"><a href="#2-8-方法" class="headerlink" title="2.8 方法"></a>2.8 方法</h2><h3 id="有参方法"><a href="#有参方法" class="headerlink" title="有参方法"></a>有参方法</h3><pre><code>// 参数 a，b
public void 方法名 (int a, int b) {

}</code></pre><h3 id="无参方法"><a href="#无参方法" class="headerlink" title="无参方法"></a>无参方法</h3><pre><code>// 没有参数
public void 方法名 () {

}</code></pre><h3 id="有返回方法"><a href="#有返回方法" class="headerlink" title="有返回方法"></a>有返回方法</h3><pre><code>// int 对应 int
public int 方法名 () {
    return 值(必须 int 类型);
}</code></pre><h3 id="无返回方法"><a href="#无返回方法" class="headerlink" title="无返回方法"></a>无返回方法</h3><pre><code>// void
public void 方法名 () {

}</code></pre><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><ul>
<li><p>方法名相同，带参数目不同，或者带参类型不同，多类型参数顺序不同。</p>
<pre><code>public void sum (int a) {

}
// 参数数目不同
public void sum (int a, int b) {

}
// 带参类型不同
public void sum (int a, long b) {

}
// 多类型顺序不同
public void sum (long a, int b) {

}</code></pre></li>
</ul>
<h2 id="2-9-流程"><a href="#2-9-流程" class="headerlink" title="2.9 流程"></a>2.9 流程</h2><ul>
<li><p>顺序结构</p>
<ul>
<li>自上而下</li>
</ul>
</li>
<li><p>选择结构</p>
<pre><code>// if---else
if (关系表达式) {

} else if (关系表达式) {

} else {

}

// switch--case
// 常量不可以一样
// break不可以去掉，否则会穿透case
// default为首尾，如若表达式都不满足case常量则将走default
switch (表达式) {
    case 常量1:
        break;  
    case 常量2:
        break;
    ......
    default:
        break;
}</code></pre></li>
<li><p>循环结构</p>
<pre><code>// for循环
// 先执行 1 再执行 2，若 2 为 true 则执行 4，再执行 3 
// 进而执行 2 若还为 true 则继续执行 4...
// 直至 2 为 false则直接结束;
for (初始化表达式 1; 布尔表达式 2; 步进表达式 3) {
    循环体 4;
}

// while循环
while (条件判断) {
    循环体
}

// do--while循环
do {
    循环体
} while (条件判断);</code></pre></li>
</ul>
<h2 id="2-10-数组"><a href="#2-10-数组" class="headerlink" title="2.10 数组"></a>2.10 数组</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>查询快，增删慢。</p>
</li>
<li><p>动态初始化</p>
<pre><code>int[] array = new int[100];</code></pre></li>
<li><p>静态初始化</p>
<pre><code>int[] array = new int[] {1, 2, 3};
int[] array = {1, 2, 3};</code></pre></li>
</ul>
<p><strong>输出数组得到（内存地址值）：</strong> [I@75412c2f</p>
<p>其中<code>[</code>表示数组，<code>I</code>表示数组类型为 int 类型，<code>@75412c2f</code></p>
<h2 id="2-11-java的内存划分"><a href="#2-11-java的内存划分" class="headerlink" title="2.11 java的内存划分"></a>2.11 java的内存划分</h2><ol>
<li><p><strong>栈（Stack）</strong> ：存放的都是方法中的局部变量。<strong>方法的运行一定要在栈当中运行。</strong></p>
<ul>
<li>局部变量：方法的参数，或者时方法{}内部的变量。</li>
<li>作用域：一旦超出作用域，立即从栈内存中消失。</li>
</ul>
</li>
<li><p><strong>堆（Heap）</strong> ： <strong>凡是 new 出来的东西，都在堆当中。</strong></p>
<ul>
<li>堆内存里面的东西都有一个地址值：16进制。</li>
<li>堆内存里面的数据，都有默认值。</li>
<li>默认值规则：<ul>
<li>整数 ====== 默认为 0</li>
<li>浮点数 ===== 默认为 0.0</li>
<li>字符 ====== 默认为 ‘\u0000’</li>
<li>布尔 ====== 默认为 false</li>
<li>引用类型 === 默认为 null</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>方法区（Method Area）</strong> ： 存放 <code>.class</code> 相关信息，包含方法的信息。</p>
</li>
<li><p>本地方法栈（Native Method Stack） ： 与操作系统有关</p>
</li>
<li><p>寄存器（PC Register） ： 与 CPU 相关</p>
</li>
</ol>
<h2 id="2-12-面对对象"><a href="#2-12-面对对象" class="headerlink" title="2.12 面对对象"></a>2.12 面对对象</h2><h3 id="2-12-1-面对对象-封装性"><a href="#2-12-1-面对对象-封装性" class="headerlink" title="2.12.1 面对对象-封装性"></a>2.12.1 面对对象-封装性</h3><h4 id="封装性的体现"><a href="#封装性的体现" class="headerlink" title="封装性的体现"></a>封装性的体现</h4><ul>
<li>方法就是一种封装体现</li>
<li>private关键字也是一种封装体现</li>
</ul>
<h3 id="2-12-2-面对对象-继承性-extends"><a href="#2-12-2-面对对象-继承性-extends" class="headerlink" title="2.12.2 面对对象-继承性 ( extends )"></a>2.12.2 面对对象-继承性 ( <code>extends</code> )</h3><h4 id="继承特性"><a href="#继承特性" class="headerlink" title="继承特性"></a>继承特性</h4><ul>
<li>单继承性 ： 一个子类最多只能有一个父类</li>
<li>多级继承性 ： 一个子类可以有一个父类，并且也可以有一个爷类（父类的父类）以及更高</li>
<li>多兄弟类性 ：一个父类可被多个子类继承</li>
</ul>
<h4 id="方法重写-Override"><a href="#方法重写-Override" class="headerlink" title="方法重写 ( @Override )"></a>方法重写 ( <code>@Override</code> )</h4><ul>
<li>保证父子类重写的方法名相同，参数也相同。</li>
<li>子类重写方法返回值必须【<strong>小于等于</strong>】父类方法的返回值范围</li>
<li>子类重写方法的权限修饰符必须【<strong>大于等于</strong>】父类方法权限修饰符</li>
<li>修饰符：public &gt; protected &gt; (default) &gt; private</li>
</ul>
<h3 id="2-12-3-面对对象-多态性"><a href="#2-12-3-面对对象-多态性" class="headerlink" title="2.12.3 面对对象-多态性"></a>2.12.3 面对对象-多态性</h3><h4 id="多态性的体现"><a href="#多态性的体现" class="headerlink" title="多态性的体现"></a>多态性的体现</h4><ul>
<li><code>父类名 对象名 = new 子类名();</code></li>
<li><code>接口名 对象名 = new 实现类名();</code></li>
</ul>
<h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><ul>
<li>向上转型一定是安全的，从小范围转向大范围</li>
<li>格式：<code>父类名 对象名 = new 子类名();</code></li>
<li>例如：( 将猫看成动物 )</li>
<li><code>Animal animal = new Cat();</code></li>
</ul>
<h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><ul>
<li>把一个父类对象【还原】成子类对象</li>
<li>格式：<code>子类名 对象名 = (子类名) 父类对象;</code></li>
<li>例如：( 将动物还原成猫 )</li>
<li><code>Animal animal = new Cat();</code></li>
<li><code>Cat cat = (Cat) animal;</code></li>
<li><strong>注意：</strong> 创建时本来就为猫，才能向下转型。可通过 <code>instanceof</code> 来判断本为的子类。</li>
<li>例如：(本来为猫，硬转狗。因此会报错)</li>
<li><code>Dog dog = (Dog) animal;</code></li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>成员变量：编译看右，运行看左</li>
<li>例如：</li>
<li><code>Fu obj = new Zi();</code></li>
<li><code>obj.name // 得到父类成员变量</code></li>
<li>成员方法：编译看左，运行看右</li>
<li>例如：</li>
<li><code>Fu obj = new Zi();</code></li>
<li><code>obj.show() // 子类已经重写show()方法</code></li>
<li><code>obj.showZi() // 子类特定方法showZi()。左边父类没有，因此编译时报错</code></li>
</ul>
<h2 id="2-13-字符串-String"><a href="#2-13-字符串-String" class="headerlink" title="2.13 字符串 ( String )"></a>2.13 字符串 ( <code>String</code> )</h2><h3 id="字符串底层存储"><a href="#字符串底层存储" class="headerlink" title="字符串底层存储"></a>字符串底层存储</h3><ul>
<li><code>byte[]</code> 以字节数组形式存储</li>
</ul>
<h3 id="字符串常用的-API"><a href="#字符串常用的-API" class="headerlink" title="字符串常用的 API"></a>字符串常用的 API</h3><ul>
<li>字符串构建<ul>
<li><code>String str = new String();</code></li>
<li><code>String str = new String(char[] charArray);</code></li>
<li><code>String str = new String(byte[] byteArray);</code></li>
<li><code>String str = &quot;&quot;;</code></li>
</ul>
</li>
<li>字符串</li>
</ul>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><ul>
<li>双引号直接赋值的字符串值会保存在 <strong>字符串常量池</strong> 当中</li>
<li>例如：<code>String str = &quot;asd&quot;;</code></li>
</ul>
<h2 id="2-14-静态代码块"><a href="#2-14-静态代码块" class="headerlink" title="2.14 静态代码块"></a>2.14 静态代码块</h2><pre><code>public class 类名 {
    static {
        // 内容
    }
}</code></pre><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul>
<li>静态代码块在第一次被使用时运行一次，其余都不再运行。</li>
</ul>
<h2 id="2-15-抽象类和抽象方法-abstract"><a href="#2-15-抽象类和抽象方法-abstract" class="headerlink" title="2.15 抽象类和抽象方法 ( abstract )"></a>2.15 抽象类和抽象方法 ( <code>abstract</code> )</h2><pre><code>public abstract class 类名 {
    public abstract void 方法名 () {

    }
}</code></pre><h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><ul>
<li>具有抽象方法的类必须为抽象类，抽象类不一定有抽象方法</li>
<li>使用时不能直接 <code>new</code> 抽象类</li>
<li>使用时必须用一个子类继承抽象类，再通过 <code>new</code> 子类来使用</li>
</ul>
<h2 id="2-16-接口-interface"><a href="#2-16-接口-interface" class="headerlink" title="2.16 接口 ( interface )"></a>2.16 接口 ( <code>interface</code> )</h2><pre><code>public interface 接口名 {

    // 常量定义
    public static final int 成员变量名 = 值;

    // 抽象方法定义
    public abstract void 方法名 ();

    // 默认方法定义
    public default void 方法名 () {
        // 内容
    }

    // 静态方法定义
    public static void 方法名 () {
        // 内容
    }

    // 私有方法定义
    private void 方法名 () {
        // 内容
    }
    private static void 方法名 () {

    }
}</code></pre><h3 id="接口可定义内容"><a href="#接口可定义内容" class="headerlink" title="接口可定义内容"></a>接口可定义内容</h3><ul>
<li>JDK 7<ul>
<li>常量</li>
<li>抽象方法 (abstract)</li>
</ul>
</li>
<li>JDK 8<ul>
<li>包含 JDK 7</li>
<li>默认方法 (default)</li>
<li>静态方法 (static)</li>
</ul>
</li>
<li>JDK 9+<ul>
<li>包含 JDK 8</li>
<li>私有方法 (private)</li>
</ul>
</li>
</ul>
<h3 id="接口使用-implements"><a href="#接口使用-implements" class="headerlink" title="接口使用 ( implements )"></a>接口使用 ( <code>implements</code> )</h3><ul>
<li>接口不能直接 <code>new</code> 使用，必须要有实现类来使用。</li>
<li>不能使用接口实现类来调用接口中的静态方法，只能通过接口名称直接调用接口中的静态方法。</li>
</ul>
<h3 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h3><ul>
<li>接口没有构造方法以及静态代码块</li>
<li>接口中的常量可以省略 public static final 。但是即便省略了这些修饰词，默认也会带有这些修饰词</li>
<li>接口中的常量必须带值</li>
<li>编写规范：接口中的常量命名必须为全大写并且用下划线连接</li>
<li>一个类可以实现多个接口</li>
<li>如果【实现类】的多个接口当中，存在重复的默认方法，那么实现类必须对重复的默认方法进行重写覆盖</li>
<li><strong>继承优先于实现</strong>。一个类继承的父类与它实现的接口具有相同的默认方法，那么将会优先使用父类方法。</li>
<li><strong>接口与接口之间是多继承的</strong></li>
<li>如果【接口继承】的多个接口当中，存在重复的默认方法，那么实现类必须对重复的默认方法进行重写覆盖</li>
</ul>
<h2 id="2-17-内部类"><a href="#2-17-内部类" class="headerlink" title="2.17 内部类"></a>2.17 内部类</h2><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><pre><code>修饰符 class 外部类名称 {
    修饰符 class 内部类名称 {

    }
}

// 使用格式
外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();

// 也可以用外部类的成员方法调用

// 重名调用
外部类名称.this.外部类成员变量</code></pre><h4 id="注意：内用外，随意用。外用内，需要内部类对象。"><a href="#注意：内用外，随意用。外用内，需要内部类对象。" class="headerlink" title="注意：内用外，随意用。外用内，需要内部类对象。"></a>注意：内用外，随意用。外用内，需要内部类对象。</h4><h4 id="内部类可用权限修饰符：public-protected-default-private"><a href="#内部类可用权限修饰符：public-protected-default-private" class="headerlink" title="内部类可用权限修饰符：public / protected / (default) / private"></a>内部类可用权限修饰符：public / protected / (default) / private</h4><h4 id="外部类可用权限修饰符：public-default"><a href="#外部类可用权限修饰符：public-default" class="headerlink" title="外部类可用权限修饰符：public / (default)"></a>外部类可用权限修饰符：public / (default)</h4><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><pre><code>修饰符 class 外部类名称 {
    修饰符 返回类型 外部类方法名 () {
        class 局部内部类名称 {

        }
    }
}</code></pre><h4 id="注意：只能定义方法使用"><a href="#注意：只能定义方法使用" class="headerlink" title="注意：只能定义方法使用"></a>注意：只能定义方法使用</h4><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><pre><code>// 匿名内部类
接口名 对象名 = new 接口名() {
    // 
};

// 匿名对象 : 只能调用一次(个)方法
new 接口名() {
    // 
}.方法名();</code></pre><h4 id="使用场景：只需使用一次该接口的情况下，就可以使用匿名内部类"><a href="#使用场景：只需使用一次该接口的情况下，就可以使用匿名内部类" class="headerlink" title="使用场景：只需使用一次该接口的情况下，就可以使用匿名内部类"></a>使用场景：只需使用一次该接口的情况下，就可以使用匿名内部类</h4><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h4 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h4><ul>
<li>概念：将基本类型数据，包装到包装类中。</li>
</ul>
<h4 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h4><ul>
<li>概念：在包装类中取出基本类型数据。</li>
</ul>
<h4 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h4><ul>
<li>基本类型和包装类可自动相互转化</li>
</ul>
<h1 id="3-JAVA-常见类"><a href="#3-JAVA-常见类" class="headerlink" title="3 JAVA 常见类"></a>3 JAVA 常见类</h1><h2 id="3-1-Date-日期类"><a href="#3-1-Date-日期类" class="headerlink" title="3.1 Date (日期类)"></a>3.1 Date (日期类)</h2><h2 id="3-2-日期格式转换类"><a href="#3-2-日期格式转换类" class="headerlink" title="3.2  (日期格式转换类)"></a>3.2  (日期格式转换类)</h2><h2 id="3-3-Calendar-日历类"><a href="#3-3-Calendar-日历类" class="headerlink" title="3.3 Calendar (日历类)"></a>3.3 Calendar (日历类)</h2><h3 id="注意：Calendar类是一个抽象类"><a href="#注意：Calendar类是一个抽象类" class="headerlink" title="注意：Calendar类是一个抽象类"></a>注意：Calendar类是一个抽象类</h3><h3 id="常用成员方法"><a href="#常用成员方法" class="headerlink" title="常用成员方法"></a>常用成员方法</h3><ul>
<li>静态方法 <code>getInstance()</code> 利用当前时间创建一个日历。</li>
<li><code>get(int field)</code> 返回给定日期值</li>
<li><code>set(int field, int value)</code> 设定定日期值</li>
<li><code>add(int field, int amount)</code> 给指定日期增加或者减少相应值</li>
</ul>
<h2 id="3-4-System"><a href="#3-4-System" class="headerlink" title="3.4 System"></a>3.4 System</h2><h3 id="常用成员方法-1"><a href="#常用成员方法-1" class="headerlink" title="常用成员方法"></a>常用成员方法</h3><ul>
<li>静态方法<code>long currentTimeMillis()</code>返回以毫秒为单位的当前时间</li>
<li>静态方法<code>void arraycopy(参数列表)</code>将数组中指定的数据拷贝到指定数组当中</li>
</ul>
<h2 id="3-5-StringBuilder-字符串缓冲区"><a href="#3-5-StringBuilder-字符串缓冲区" class="headerlink" title="3.5 StringBuilder (字符串缓冲区)"></a>3.5 StringBuilder (字符串缓冲区)</h2><h3 id="常用成员方法-2"><a href="#常用成员方法-2" class="headerlink" title="常用成员方法"></a>常用成员方法</h3><ul>
<li><code>append(...)</code> 往对象中加入数据，返回<code>this</code></li>
<li><code>reverse()</code> 反转对象内容</li>
</ul>
<h1 id="4-JAVA-基础"><a href="#4-JAVA-基础" class="headerlink" title="4 JAVA 基础"></a>4 JAVA 基础</h1><h2 id="4-1-集合"><a href="#4-1-集合" class="headerlink" title="4.1 集合"></a>4.1 集合</h2><h3 id="4-1-1-Collection-接口"><a href="#4-1-1-Collection-接口" class="headerlink" title="4.1.1 Collection 接口"></a>4.1.1 Collection 接口</h3><ul>
<li>定义的是所有单列集合中共性的方法(最顶层接口)</li>
<li>没有带索引的方法</li>
<li>子接口<ul>
<li>List 接口</li>
<li>Set 接口</li>
</ul>
</li>
</ul>
<h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><ul>
<li><code>boolean add(E e);</code> // 向集合中添加元素</li>
<li><code>boolean remove(E e);</code> // 删除集合中某元素</li>
<li><code>void clean();</code> // 清除集合中的所有元素</li>
<li><code>boolean contains(E e);</code> // 判断集合中是否包含某元素</li>
<li><code>boolean isEmpty();</code> // 判断集合是否为空</li>
<li><code>int size();</code> // 获取集合长度</li>
<li><code>Object toArray();</code> // 将集合转成一个数组</li>
<li><code>Iterator&lt;E&gt; iterator();</code> // 获取迭代器</li>
</ul>
<h3 id="4-1-2-List-接口"><a href="#4-1-2-List-接口" class="headerlink" title="4.1.2 List 接口"></a>4.1.2 List 接口</h3><ul>
<li>有序集合(存储和取出元素顺序相同)</li>
<li>允许存储重复(相同)元素</li>
<li>有索引，可使用普通 <code>for</code> 循环遍历</li>
<li>实现类<ul>
<li>ArrayList</li>
<li>LinkedList</li>
<li>Vector<ul>
<li>底层数组实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="常用成员方法-3"><a href="#常用成员方法-3" class="headerlink" title="常用成员方法"></a>常用成员方法</h4><ul>
<li><code>void add(int index, E element)</code> // 指定位置插入元素</li>
<li><code>E remove(int index)</code> // 指定位置移除元素，并返回被移除的元素</li>
<li><code>E get(int index);</code> // 返回指定位置的元素</li>
<li><code>E set(int index, E element);</code> // 更换指定位置元素，并返回指定位置的原本元素</li>
</ul>
<h3 id="4-1-3-Set-接口"><a href="#4-1-3-Set-接口" class="headerlink" title="4.1.3 Set 接口"></a>4.1.3 Set 接口</h3><ul>
<li>存储无序</li>
<li>不允许存储重复(相同)元素</li>
<li>没有索引</li>
<li>实现类<ul>
<li>HashSet</li>
<li>LinkedHashSet</li>
<li>TreeSet</li>
</ul>
</li>
</ul>
<h3 id="4-1-4-ArrayList"><a href="#4-1-4-ArrayList" class="headerlink" title="4.1.4 ArrayList"></a>4.1.4 ArrayList</h3><h4 id="特点：底层数组实现，查询快，增删慢"><a href="#特点：底层数组实现，查询快，增删慢" class="headerlink" title="特点：底层数组实现，查询快，增删慢"></a>特点：底层数组实现，查询快，增删慢</h4><h4 id="常用成员方法-4"><a href="#常用成员方法-4" class="headerlink" title="常用成员方法"></a>常用成员方法</h4><ul>
<li><code>void add(int index, E element)</code> // 指定位置插入元素</li>
<li><code>E remove(int index)</code> // 指定位置移除元素，并返回被移除的元素</li>
<li><code>E get(int index);</code> // 返回指定位置的元素</li>
<li><code>E set(int index, E element);</code> // 更换指定位置元素，并返回指定位置的原本元素</li>
</ul>
<h3 id="4-1-5-LinkedList"><a href="#4-1-5-LinkedList" class="headerlink" title="4.1.5 LinkedList"></a>4.1.5 LinkedList</h3><h4 id="特点：底层链表实现，查询慢，增删快"><a href="#特点：底层链表实现，查询慢，增删快" class="headerlink" title="特点：底层链表实现，查询慢，增删快"></a>特点：底层链表实现，查询慢，增删快</h4><h4 id="注意：LinkedList-不可以使用多态写法"><a href="#注意：LinkedList-不可以使用多态写法" class="headerlink" title="注意：LinkedList 不可以使用多态写法"></a>注意：LinkedList 不可以使用多态写法</h4><h4 id="常用成员方法-5"><a href="#常用成员方法-5" class="headerlink" title="常用成员方法"></a>常用成员方法</h4><ul>
<li><code>void addFirst(E element)</code> // 在链表的开头插入元素</li>
<li><code>void addLast(E element)</code> // 在链表的结尾插入元素</li>
<li><code>void push(E element)</code> // 在链表的开头插入元素</li>
<li><code>E removeFirst()</code> // 移除链表开头元素，并返回被移除的元素</li>
<li><code>E removeLast()</code> // 移除链表结尾元素，并返回被移除的元素</li>
<li><code>E pop()</code> // 移除链表开头元素，并返回被移除的元素</li>
<li><code>E getFirst();</code> // 返回链表开头的元素</li>
<li><code>E getLast();</code> // 返回链表结尾的元素</li>
</ul>
<h3 id="4-1-6-HashSet"><a href="#4-1-6-HashSet" class="headerlink" title="4.1.6 HashSet"></a>4.1.6 HashSet</h3><h4 id="特点：底层哈希表-红黑树-实现，无索引，存储元素不会重复，存取无序"><a href="#特点：底层哈希表-红黑树-实现，无索引，存储元素不会重复，存取无序" class="headerlink" title="特点：底层哈希表+(红黑树)实现，无索引，存储元素不会重复，存取无序"></a>特点：底层哈希表+(红黑树)实现，无索引，存储元素不会重复，存取无序</h4><h4 id="HashSet-存储元素不会重复情况"><a href="#HashSet-存储元素不会重复情况" class="headerlink" title="HashSet 存储元素不会重复情况"></a>HashSet 存储元素不会重复情况</h4><ul>
<li><code>add(E element);</code> 方法会调用 <code>hashCode()</code> 的方法计算哈希值</li>
<li>再在集合当中查找有没有 <strong>哈希冲突 （相同哈希值）</strong> </li>
<li>若有，则调用 <code>equals();</code> 方法判断元素是否重复。</li>
</ul>
<h4 id="HashSet-存储自定义类"><a href="#HashSet-存储自定义类" class="headerlink" title="HashSet 存储自定义类"></a>HashSet 存储自定义类</h4><ul>
<li>必须重写 <code>hashCode()</code> 方法和 <code>equals()</code> 方法</li>
</ul>
<h3 id="4-1-6-LinkedHashSet"><a href="#4-1-6-LinkedHashSet" class="headerlink" title="4.1.6 LinkedHashSet"></a>4.1.6 LinkedHashSet</h3><h4 id="特点：底层哈希表-链表（记住元素顺序）实现，无索引，不可存储重复元素，可以保证存取顺序"><a href="#特点：底层哈希表-链表（记住元素顺序）实现，无索引，不可存储重复元素，可以保证存取顺序" class="headerlink" title="特点：底层哈希表+链表（记住元素顺序）实现，无索引，不可存储重复元素，可以保证存取顺序"></a>特点：底层哈希表+链表（记住元素顺序）实现，无索引，不可存储重复元素，可以保证存取顺序</h4><h3 id="4-1-6-TreeSet"><a href="#4-1-6-TreeSet" class="headerlink" title="4.1.6 TreeSet"></a>4.1.6 TreeSet</h3><h4 id="特点：底层二叉树实现，一般用于排序"><a href="#特点：底层二叉树实现，一般用于排序" class="headerlink" title="特点：底层二叉树实现，一般用于排序"></a>特点：底层二叉树实现，一般用于排序</h4><h3 id="4-1-7-Collections-集合工具类"><a href="#4-1-7-Collections-集合工具类" class="headerlink" title="4.1.7 Collections ( 集合工具类 )"></a>4.1.7 Collections ( 集合工具类 )</h3><h4 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h4><ul>
<li>静态方法 <code>boolean addAll(Collections&lt;T&gt; collections, T...element)</code> // 往集合中添加多个元素</li>
<li>静态方法 <code>void shuffle(List&lt;?&gt; list)</code> // 打乱集合顺序</li>
<li>静态方法 <code>void sort(List&lt;T&gt; list)</code> // 将集合中的元素按默认规则排序<ul>
<li>注意：对自定义类集合排序的前提是，自定义类必须实现 <code>Comparable</code> 接口，并重写 <code>compare(...)</code> 方法 (排序规则方法)</li>
</ul>
</li>
<li>静态方法 <code>void sort(List&lt;T&gt; list, Collections&lt;? super T&gt;)</code> // 将集合中的元素按自定义规则排序</li>
</ul>
<h2 id="4-2-扩展-——-数据结构"><a href="#4-2-扩展-——-数据结构" class="headerlink" title="4.2 扩展 —— 数据结构"></a>4.2 扩展 —— 数据结构</h2><h3 id="4-2-1-栈-Stack"><a href="#4-2-1-栈-Stack" class="headerlink" title="4.2.1 栈 ( Stack )"></a>4.2.1 栈 ( Stack )</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>元素 <strong>先进后出</strong></li>
<li>例如：子弹弹夹</li>
</ul>
<h3 id="4-2-2-队列"><a href="#4-2-2-队列" class="headerlink" title="4.2.2 队列"></a>4.2.2 队列</h3><h4 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h4><ul>
<li>元素 <strong>先进先出</strong></li>
<li>例如：排队</li>
</ul>
<h3 id="4-2-3-链表"><a href="#4-2-3-链表" class="headerlink" title="4.2.3 链表"></a>4.2.3 链表</h3><h4 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h4><ul>
<li>查询慢，增删快</li>
<li>地址不是连续的，查询必须从头开始查询。</li>
</ul>
<h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><h3 id="4-2-4-红黑树"><a href="#4-2-4-红黑树" class="headerlink" title="4.2.4 红黑树"></a>4.2.4 红黑树</h3><h4 id="特性-3"><a href="#特性-3" class="headerlink" title="特性"></a>特性</h4><ul>
<li>趋近于平衡二叉树(左孩子==右孩子)，查询快，最深叶子层数不超过最浅叶子层数的 <strong>2</strong> 倍</li>
<li>约束<ul>
<li>节点可以是红色或者黑色的</li>
<li>根节点是黑色的</li>
<li>叶子节点是黑色的</li>
<li>每个红色的节点的子节点都是黑色的</li>
<li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li>
</ul>
</li>
</ul>
<h3 id="4-2-5-哈希表"><a href="#4-2-5-哈希表" class="headerlink" title="4.2.5 哈希表"></a>4.2.5 哈希表</h3><h4 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h4><ul>
<li>是一个十进制的整数，由系统给出。</li>
</ul>
<h4 id="JDK-版本哈希表情况"><a href="#JDK-版本哈希表情况" class="headerlink" title="JDK 版本哈希表情况"></a>JDK 版本哈希表情况</h4><ul>
<li>JDK 8 之前：哈希表 = 数组 + 链表；</li>
<li>JDK 8 之后：<ul>
<li>哈希表 = 数组 + 链表（当链表长度大于 <strong>8</strong> 时就会将链表转化成红黑树）</li>
<li>哈希表 = 数组 + 红黑树（提高查询效率）</li>
</ul>
</li>
</ul>
<h3 id="4-2-6-递归"><a href="#4-2-6-递归" class="headerlink" title="4.2.6 递归"></a>4.2.6 递归</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>自己调用自己</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>直接递归<ul>
<li>自身调用自身</li>
</ul>
</li>
<li>间接递归<ul>
<li>自身调用其他方法，其他方法再次调用自身</li>
</ul>
</li>
</ul>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul>
<li>递归一定要有结束条件，否则会发生栈内存溢出 (栈是方法<br>被调用时会进栈，方法结束时会直接出栈。若递归没有结束条件，那么方法会一直被调用，且方法都不会结束。最后超出栈的内存)</li>
<li>递归次数不能过多，否则也会发生栈内存溢出。原理与上差不多</li>
<li>构造方法禁止递归</li>
</ul>
<h2 id="4-3-Iterator-接口-迭代器"><a href="#4-3-Iterator-接口-迭代器" class="headerlink" title="4.3 Iterator 接口 ( 迭代器 )"></a>4.3 Iterator 接口 ( 迭代器 )</h2><h3 id="迭代概念"><a href="#迭代概念" class="headerlink" title="迭代概念"></a>迭代概念</h3><ul>
<li>在取出元素之前要先进行判断集合中是否有元素，如果有则将其取出，继续判断，还有则继续取出，一直到没有元素(全部元素取出)。</li>
</ul>
<h3 id="成员方法-2"><a href="#成员方法-2" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><code>boolean hasNext();</code> // 判断集合是否还有下一个元素</li>
<li><code>String next();</code> // 取出元素</li>
</ul>
<h2 id="4-4-泛型"><a href="#4-4-泛型" class="headerlink" title="4.4 泛型"></a>4.4 泛型</h2><h3 id="在不知道该用什么数据类型时可以使用泛型"><a href="#在不知道该用什么数据类型时可以使用泛型" class="headerlink" title="在不知道该用什么数据类型时可以使用泛型"></a>在不知道该用什么数据类型时可以使用泛型</h3><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><ul>
<li>泛型通配符为 <code>?</code></li>
<li>不能在 <code>new</code> 对象时使用</li>
<li>只能作为方法参数使用</li>
</ul>
<h3 id="泛型的上限限定"><a href="#泛型的上限限定" class="headerlink" title="泛型的上限限定"></a>泛型的上限限定</h3><ul>
<li>格式：<code>? extends E</code></li>
<li>代表使用的泛型只能是 E 类型的子类或者本身</li>
</ul>
<h3 id="泛型的下限限定"><a href="#泛型的下限限定" class="headerlink" title="泛型的下限限定"></a>泛型的下限限定</h3><ul>
<li>格式：<code>? super E</code></li>
<li>代表使用的泛型只能是 E 类型的父类或者本身</li>
</ul>
<h2 id="4-5-可变参数"><a href="#4-5-可变参数" class="headerlink" title="4.5 可变参数"></a>4.5 可变参数</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul>
<li>JDK 1.5 之后出现的新特性</li>
<li><strong>一个方法只能有一个可变参数</strong></li>
<li><strong>一个方法有多种参数，可变参数必须放至末尾</strong></li>
<li>前提：定义方法时使用。方法的参数列表数据类型已确定，但是参数数目不确定，就可使用可变参数。</li>
<li>格式：<code>修饰符 返回类型 方法名 (数据类型...参数名) {}</code></li>
<li>原理：可变参数底层为数组，根据参数的不同会创建不同长度的数组来存储这些参数。</li>
</ul>
<h2 id="4-6-Map-lt-K-V-gt-接口"><a href="#4-6-Map-lt-K-V-gt-接口" class="headerlink" title="4.6 Map&lt;K, V&gt; 接口"></a>4.6 Map&lt;K, V&gt; 接口</h2><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>Map集合是一个双列集合，一个元素包含两个值(Key, Value)</li>
<li>Map集合中的元素，key和value的数据类型可以相同，也可以不同</li>
<li>Map集合中的元素，key是不允许重复的，value是可以重复的</li>
<li>Map集合中的元素，keyhevalue是一一对应的</li>
</ul>
<h4 id="常用成员方法-6"><a href="#常用成员方法-6" class="headerlink" title="常用成员方法"></a>常用成员方法</h4><ul>
<li><code>V put(K key, V value);</code> // 把指定的 key 和 value 加入到 map 当中，返回被替换的元素</li>
<li><code>V remove(Object key);</code> // 把指定的 key 所对应的 value 从 map 中删除，返回被删除的元素</li>
<li><code>V get(Object key);</code> // 通过 key 返回对应的 value</li>
<li><code>boolean containsKey(Object key);</code> // 判断是否包含指定的 key</li>
<li><code>Set&lt;K&gt; keySet();</code> // 将集合中所有的 key 取出来保存到 Set 集合中</li>
<li><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</code> // 将 map 集合中所有的 Entry 对象取出来保存到 Set 集合中</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>底层哈希表实现，查询速度快</li>
<li>无序集合，存取顺序可能不一致</li>
<li>是一个线程不安全集合，多线程集合，速度快</li>
</ul>
<h4 id="HashMap-存储自定义类键-key-值"><a href="#HashMap-存储自定义类键-key-值" class="headerlink" title="HashMap 存储自定义类键(key)值"></a>HashMap 存储自定义类键(key)值</h4><ul>
<li>key : 自定义类型<ul>
<li>自定义类必须重写 <code>hashCode()</code> 方法和 <code>equals()</code> 方法，以保证 key 的唯一</li>
</ul>
</li>
</ul>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ul>
<li>底层哈希表+链表实现（保存迭代顺序）</li>
<li>有序集合，存取顺序是一致的</li>
</ul>
<h3 id="Hashtable-lt-K-V-gt"><a href="#Hashtable-lt-K-V-gt" class="headerlink" title="Hashtable&lt;K, V&gt;"></a>Hashtable&lt;K, V&gt;</h3><h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ul>
<li>底层为哈希表</li>
<li>是一个线程安全集合，单线程集合，速度慢</li>
<li>Hashtable 不可以存储 <code>null</code> 值</li>
</ul>
<h3 id="Entry-lt-K-V-gt-键-key-值-value-对对象"><a href="#Entry-lt-K-V-gt-键-key-值-value-对对象" class="headerlink" title="Entry&lt;K, V&gt; ( 键(key)值(value)对对象 )"></a>Entry&lt;K, V&gt; ( 键(key)值(value)对对象 )</h3><h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ul>
<li>当 Map 集合一创建，那么就会在 Map 集合中创建一个  Entry 对象来记录键(key)与值(value)</li>
</ul>
<h2 id="4-7-异常-Exception"><a href="#4-7-异常-Exception" class="headerlink" title="4.7 异常 ( Exception )"></a>4.7 异常 ( <code>Exception</code> )</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li><code>try...catch...finally</code> 异常捕获<ul>
<li>多 catch 如果有子父类关系，那么子类异常类必须放至父类上面</li>
<li>try 里有异常产生则，从产生位置到 try 的 } 这些代码将不再执行，直接执行对应得 catch</li>
<li>如果 finally 中有 return 那么就会一定运行 finally 中的 return</li>
</ul>
</li>
<li><code>throw new 异常对象();</code> 抛出异常对象</li>
<li><code>thorws 异常类名1,异常类名2...</code> 声明异常</li>
</ul>
<h2 id="4-8-多线程"><a href="#4-8-多线程" class="headerlink" title="4.8 多线程"></a>4.8 多线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li><p>进入到内存中执行的程序</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3></li>
<li><p>进程中的一个执行单元</p>
</li>
<li><p>主线程 <code>main();</code></p>
</li>
<li><p>调度</p>
<ul>
<li><p>分时调度</p>
</li>
<li><p>抢占式调度 ( JAVA )</p>
<pre><code>// 方法一
public class 类名 extends Thread {
    @Override
    public void run () {
        // 线程任务
    }
}

// 调用
类名 对象名 = new 类名();
对象名.start();

// 方法二
public class 类名 implements Runnable {
    @Override
    public void run () {
        // 线程任务
    }
}

// 调用
类名 对象名 = new 类名();
new Thread(对象名).start();</code></pre></li>
</ul>
</li>
</ul>
<h4 id="Thread-与-Runnable-的区别"><a href="#Thread-与-Runnable-的区别" class="headerlink" title="Thread 与 Runnable 的区别"></a>Thread 与 Runnable 的区别</h4><ul>
<li>使用 Runnable 的好处<ul>
<li>避免了单继承的局限性</li>
<li>增强了程序的扩展性，降低了程序的耦合性 ( 解耦 )</li>
</ul>
</li>
</ul>
<h4 id="常用成员方法-7"><a href="#常用成员方法-7" class="headerlink" title="常用成员方法"></a>常用成员方法</h4><ul>
<li><code>String getName();</code> // 返回线程名称</li>
<li><code>void setName();</code> // 设置线程名称</li>
<li>静态方法 <code>Thread currentThread();</code> // 获取当前执行的线程</li>
<li>静态方法 <code>void sleep(loog millis);</code> // 让当前执行的进程按指定的毫秒数暂停（睡眠）执行</li>
</ul>
<h4 id="并发：指两个或多个事件在同一【时间】进行。交替进行"><a href="#并发：指两个或多个事件在同一【时间】进行。交替进行" class="headerlink" title="并发：指两个或多个事件在同一【时间】进行。交替进行"></a>并发：指两个或多个事件在同一【时间】进行。交替进行</h4><h4 id="并行：指两个或多个事件在同一【时刻】进行。同时进行"><a href="#并行：指两个或多个事件在同一【时刻】进行。同时进行" class="headerlink" title="并行：指两个或多个事件在同一【时刻】进行。同时进行"></a>并行：指两个或多个事件在同一【时刻】进行。同时进行</h4><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><ul>
<li>多个线程对同一个资源进行操作时，可能会出现线程安全问题。</li>
<li>例如：卖票</li>
</ul>
<h4 id="解决线程安全"><a href="#解决线程安全" class="headerlink" title="解决线程安全"></a>解决线程安全</h4><ul>
<li>同步技术 ( <code>synchronized</code> 关键字 )<ul>
<li>同步代码块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object 锁对象 &#x3D; new Object();</span><br><span class="line">synchronized (锁对象) &#123;</span><br><span class="line">    &#x2F;&#x2F; 可能出现线程安全代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>同步方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 synchronized 返回类型 方法名 () &#123;</span><br><span class="line">    &#x2F;&#x2F; 可能出现线程安全代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>静态同步方法</li>
</ul>
</li>
<li>Lock 锁<ul>
<li>其中一个实现类 <code></code></li>
<li>常用成员方法<ul>
<li><code>void lock();</code> // 获取锁</li>
<li><code>void unlock();</code> // 释放锁</li>
</ul>
</li>
<li>使用<ul>
<li>在可能出现线程安全代码前获取锁</li>
<li>在可能出现线程安全代码后释放锁</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><ul>
<li>计时等待 <code>sleep(long millis)</code> == <code>wait(long millis)</code></li>
<li>锁阻塞 <code></code></li>
<li>无限等待 <code>wait()</code></li>
<li>随机唤醒单个等待得线程 <code>notify()</code></li>
<li>唤醒全部等待得线程 <code>notifyAll()</code></li>
</ul>
<h4 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h4><ul>
<li>线程间等待唤醒相互调用 </li>
<li>无限等待 <code>wait()</code></li>
<li>随机唤醒单个等待得线程 <code>notify()</code></li>
<li>唤醒全部等待得线程 <code>notifyAll()</code></li>
</ul>
<h5 id="注意：wait-notify-notifyAll-必须得用【锁对象】调用，且只能在同一同步代码块或者方法当中。"><a href="#注意：wait-notify-notifyAll-必须得用【锁对象】调用，且只能在同一同步代码块或者方法当中。" class="headerlink" title="注意：wait() | notify() | notifyAll() 必须得用【锁对象】调用，且只能在同一同步代码块或者方法当中。"></a>注意：<code>wait()</code> | <code>notify()</code> | <code>notifyAll()</code> 必须得用【锁对象】调用，且只能在同一同步代码块或者方法当中。</h5><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><ul>
<li>概念：<ul>
<li>创建多个线程保存在一个集合当中。这个集合就是线程池。当想用线程时就可以拿出来使用，用完后再归还集合 (线程池)</li>
</ul>
</li>
<li>JDK 1.5 之后，JDK 就内置了线程池。可以直接使用。<ul>
<li><code>Executors</code> 是线程池的工厂类，用来生产线程池<ul>
<li>静态方法 <code>ExecutorService newFixedThreadPool(int nThreads)</code> // 创建一个线程池，返回的是一个线程池接口</li>
</ul>
</li>
<li><code>ExecutorService</code> 线程池接口，用来从线程池中获取线程<ul>
<li><code>submit(Runnable task)</code> // 提交一个 Runnable 任务用于执行</li>
<li><code>void shutdown()</code> // 销毁/关闭一个线程池</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-9-Lambda-表达式"><a href="#4-9-Lambda-表达式" class="headerlink" title="4.9 Lambda 表达式"></a>4.9 Lambda 表达式</h2><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul>
<li>使用前提<ul>
<li>必须有接口，且接口中有且仅有一个抽象方法</li>
<li>必须有上下文推断</li>
</ul>
</li>
<li>简化匿名内部类</li>
</ul>
<h3 id="可省略内容及要求"><a href="#可省略内容及要求" class="headerlink" title="可省略内容及要求"></a>可省略内容及要求</h3><ul>
<li>(参数列表) : 括号中参数列表的【数据类型】可以省略不写</li>
<li>(参数列表) : 括号中参数列表只有一个，那么【数据类型】和【( )】都可以省略不写</li>
<li>{方法体代码} : </li>
</ul>
<h3 id="格式-：-由三部分组成"><a href="#格式-：-由三部分组成" class="headerlink" title="格式 ： 由三部分组成"></a>格式 ： 由三部分组成</h3><ul>
<li><p>一些参数</p>
</li>
<li><p>一个箭头</p>
</li>
<li><p>一段代码</p>
<pre><code>(参数列表) -&gt; {
    // 方法体代码
}</code></pre></li>
</ul>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><ul>
<li>格式 <code>类名(对象名) :: 方法名</code></li>
<li>例如：<ul>
<li><code>this::本类方法名</code></li>
<li><code>super::父类方法名</code></li>
<li><code>类名::静态方法名</code></li>
<li><code>对象名::该类方法名</code></li>
<li><code>类名::new</code> : 引用构造函数</li>
</ul>
</li>
</ul>
<h2 id="4-10-IO"><a href="#4-10-IO" class="headerlink" title="4.10 IO"></a>4.10 IO</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>I : input ( 读取 )<ul>
<li>硬盘 —&gt; 内存</li>
</ul>
</li>
<li>O : output ( 写入 )<ul>
<li>内存 —&gt; 硬盘</li>
</ul>
</li>
<li>流 : 数据<ul>
<li>字符流<ul>
<li>输入流 : <code>InputStream</code></li>
<li>输出流 : <code>OutputStream</code></li>
</ul>
</li>
<li>字节流<ul>
<li>输入流 : <code>Reader</code></li>
<li>输出流 : <code>Writer</code></li>
</ul>
</li>
<li>1 个字符 = 2 个字节</li>
<li>1 个字节 = 8 个位 (二进制)</li>
</ul>
</li>
</ul>
<h3 id="4-10-1-File-类"><a href="#4-10-1-File-类" class="headerlink" title="4.10.1 File 类"></a>4.10.1 File 类</h3><h4 id="常用静态成员变量"><a href="#常用静态成员变量" class="headerlink" title="常用静态成员变量"></a>常用静态成员变量</h4><ul>
<li><code>String pathSeparator</code> // 与系统有关的路径分隔符，字符串表示</li>
<li><code>Char pathSeparatorChar</code> // 与系统有关的路径分隔符，字符表示</li>
<li><code>String separator</code> // 与系统有关的默认名称分隔符，字符串表示</li>
<li><code>Char separatorChar</code> // 与系统有关的默认名称分隔符，字符表示</li>
</ul>
<h4 id="常用成员方法-8"><a href="#常用成员方法-8" class="headerlink" title="常用成员方法"></a>常用成员方法</h4><ul>
<li>获取功能方法 <ul>
<li><code>String getAbsolutePath();</code> // 获取此 File 的绝对路径名字字符串</li>
<li><code>String getPath();</code> // 获取此 File 的路径名字字符串，分绝对路径和相对路径</li>
<li><code>String getName();</code> // 获取此 File 的名称，文件会有后缀</li>
<li><code>long length();</code> // 获取此 File 的大小，字节为单位。<strong>注意：文件夹没有大小概念。</strong></li>
</ul>
</li>
<li>判断功能方法<ul>
<li><code>boolean exists();</code> // 判断 File 表示的文件或者文件夹是否存在</li>
<li><code>boolean isDirectory();</code> // 判断 File 表示的是否为文件夹</li>
<li><code>boolean isFile();</code> // 判断 File 表示的是否为文件</li>
</ul>
</li>
<li>创建删除功能方法<ul>
<li><code>boolean craeteNewFile();</code> // 创建一个新的空文件，前提为这个文件不存在，且路径必须存在。该方法只能创建文件</li>
<li><code>boolean delete();</code> // 删除 File 表示的文件或者文件夹，文件中有内容不会被删除</li>
<li><code>boolean mkdir();</code> // 创建 File 表示的单级文件夹，前提路径必须存在</li>
<li><code>boolean mkdirs();</code> // 创建 File 表示的单级文件夹或者多级文件夹，前提根目录必须存在</li>
</ul>
</li>
<li>遍历目录功能方法<ul>
<li><code>String[] list();</code> // 获取此 File 目录中所有子文件或者目录 (文件夹)的名称，存入字符串数组并返回</li>
<li><code>File[] listFiles();</code> // 获取此 File 目录中所有子文件或者目录 (文件夹)，存入 File 数组并返回</li>
</ul>
</li>
</ul>
<h4 id="文件过滤器"><a href="#文件过滤器" class="headerlink" title="文件过滤器"></a>文件过滤器</h4><ul>
<li>FileFilter 接口</li>
<li>FilenameFilter 接口</li>
</ul>
<h3 id="4-10-2-字节流"><a href="#4-10-2-字节流" class="headerlink" title="4.10.2 字节流"></a>4.10.2 字节流</h3><ul>
<li><code>OutputStream</code> // 字节输出流，是个抽象类<ul>
<li>写入到文件当中 ( 本身为字节 )</li>
<li><code>void close();</code> // 关闭并释放输出流相关的任何资源</li>
<li><code>void flush();</code> // 刷新该流缓冲</li>
<li><code>void write(byte[] bytes);</code> // 将多个字节写入此输出流</li>
<li><code>void write(byte[] bytes, int off, int len);</code> // 将多个字节写入此输出流, off 偏移值（开始索引）, len 写入长度</li>
<li><code>void write(int byte);</code> // 将单个字节写入此输出流</li>
<li>追加写/续写 : 构造时构造函数参数中的 <code>boolean append</code> 设置为 true 即可</li>
<li>换行<ul>
<li>windows : \r\n</li>
<li>linux : \n</li>
<li>mac : \r</li>
</ul>
</li>
</ul>
</li>
<li><code>InputStream</code> // 字节输入流，抽象类<ul>
<li><code>int read();</code> // 从输入流中读取数据的下一个字节</li>
<li><code>int read(byte[] b);</code> // 从输入流中读取一定量字节，并将其保存到缓存区 b 中，返回长度</li>
<li><code>void close();</code> // 关闭并释放输入流相关的任何资源</li>
</ul>
</li>
</ul>
<h3 id="4-10-3-字符流"><a href="#4-10-3-字符流" class="headerlink" title="4.10.3 字符流"></a>4.10.3 字符流</h3><ul>
<li><code>Reader</code> // 字符输入流，抽象类<ul>
<li><code>void close();</code> // 关闭并释放输入流相关的任何资源</li>
<li><code>int read();</code> // 从输入流中读取数据的下一个字符</li>
<li><code>int read(char[] c);</code> // 从输入流中读取一定量字符，并将其保存到缓存区 c 中，返回长度</li>
</ul>
</li>
<li><code>Writer</code> // 字符输出流，抽象类<ul>
<li>写入到内存当中进行 <strong>字符转字节</strong> 操作，当刷新流或者关闭流时会将数据写入到文件当中，刷新之后还可以继续使用写操作。</li>
<li><code>void close();</code> // 关闭并释放输出流相关的任何资源</li>
<li><code>void flush();</code> // 刷新该流缓冲，并将数据写入文件当中</li>
<li><code>void write(char[] c);</code> // 将多个字符写入此输出流</li>
<li><code>void write(char[] c, int off, int len);</code> // 将多个字符写入此输出流, off 偏移值（开始索引）, len 写入长度</li>
<li><code>void write(String s);</code> // 将字符串写入此输出流</li>
<li><code>void write(String[] s, int off, int len);</code> // 将多个字符串写入此输出流, off 偏移值（开始索引）, len 写入长度</li>
<li>追加写/续写 : 构造时构造函数参数中的 <code>boolean append</code> 设置为 true 即可</li>
<li>换行<ul>
<li>windows : \r\n</li>
<li>linux : \n</li>
<li>mac : \r</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-11-Properties-集合"><a href="#4-11-Properties-集合" class="headerlink" title="4.11 Properties 集合"></a>4.11 Properties 集合</h2><ul>
<li>Properties 类表示一个持久的属性集</li>
<li>Properties 可以保存在流中或在流中加载</li>
<li>Properties 集合是一个唯一和 IO 流相结合的集合<ul>
<li>Properties 中 store 方法可以把集合中的临时数据，持久化的写入到硬盘中存储</li>
<li>Properties 中 load 方法可以把硬盘中保存的文件 ( 键值对 )，读取到集合中使用</li>
</ul>
</li>
<li>Properties 是一个双列集合，key 和 value 默认都是 String</li>
</ul>
<h3 id="成员方法-3"><a href="#成员方法-3" class="headerlink" title="成员方法"></a>成员方法</h3><ul>
<li><code>Object setProperty(String key, String value)</code> 向集合中添加数据</li>
<li><code>String getProperty(String key)</code> 通过 key 来获取 value </li>
<li><code>Set&lt;String&gt; stringPropertyName()</code> 返回集合中的 key 值，并存入 Set 返回</li>
<li><code>void store(OutputStream out, String comments)</code> <ul>
<li>OutputStream : 字节输出流，不能写中文</li>
<li>comments : 备注，解释该文件用来做什么，不能写中文</li>
</ul>
</li>
<li><code>void store(Writer writer, String comments)</code><ul>
<li>Writer : 字符输出流，能写中文</li>
<li>comments : 备注，解释该文件用来做什么，不能写中文</li>
</ul>
</li>
<li><code>void load(InputStream in)</code> // InputStream : 字节输入流，不能读带中文的键值对</li>
<li><code>void load(Reader reader)</code> // Reader : 字符输入流，能读带中文的键值对<ul>
<li>文件中的键值对默认连接符号为 <code>=</code> 或者 <code>空格</code></li>
<li>文件中可以使用 <code>#</code> 注释，被注释的地方不会被读取</li>
<li>文件中的 key 和 value 默认都是字符串，不需再加 <code>&quot;&quot;</code></li>
</ul>
</li>
</ul>
<h2 id="4-12-缓存流"><a href="#4-12-缓存流" class="headerlink" title="4.12 缓存流"></a>4.12 缓存流</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>再基本的流中加多一个【缓存区 (数组)】</li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li><code>BufferedOutputStream</code></li>
<li><code>BufferedInputStream</code></li>
<li><code>BufferedReader</code><ul>
<li><code>String readLine()</code> // 读取一行数据</li>
</ul>
</li>
<li><code>BufferedWriter</code><ul>
<li><code>void newline()</code> // 写入一个分隔符，会根据操作系统获取不同分隔符</li>
</ul>
</li>
</ul>
<h2 id="4-13-转换流"><a href="#4-13-转换流" class="headerlink" title="4.13 转换流"></a>4.13 转换流</h2><h3 id="编码：字符-–-gt-字节"><a href="#编码：字符-–-gt-字节" class="headerlink" title="编码：字符 –&gt; 字节"></a>编码：字符 –&gt; 字节</h3><h3 id="解码：字节-–-gt-字符"><a href="#解码：字节-–-gt-字符" class="headerlink" title="解码：字节 –&gt; 字符"></a>解码：字节 –&gt; 字符</h3><h3 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h3><ul>
<li><code>InputStreamReader</code> // 字节流通向字符流的桥梁 == 解码</li>
<li><code>OutputStreamWriter</code> // 字符流通向字节流的桥梁 == 编码</li>
<li>都可指定码表</li>
</ul>
<h2 id="4-14-序列化-反序列化"><a href="#4-14-序列化-反序列化" class="headerlink" title="4.14 序列化/反序列化"></a>4.14 序列化/反序列化</h2><ul>
<li>序列化和反序列化的类必须实现接口 <code>Serializable</code> 否则会抛出 <code>NotSerializableException</code> 异常</li>
<li>序列化：将对象以流的方式写入到文件中保存<ul>
<li><code>ObjectOutStream</code> <ul>
<li><code>void writeObject()</code> 将对象写入到文件当中</li>
</ul>
</li>
</ul>
</li>
<li>反序列化：将文件中保存的对象以流的方式读取到内存当中<ul>
<li><code>ObjectInputStream</code> <ul>
<li><code>Object readObject()</code> 将对象读取到内存当中</li>
</ul>
</li>
</ul>
</li>
<li>序列化之后如果对类进行了修改，那么反序列化时就会抛出 <code>InvalidClassException</code> 异常<ul>
<li>可以通过自定义序列号解决, 即在类中定义成员变量 <code>static final long serialVersionUID = 值L;</code></li>
</ul>
</li>
</ul>
<h3 id="transient-关键字-瞬态关键字"><a href="#transient-关键字-瞬态关键字" class="headerlink" title="transient 关键字 : 瞬态关键字"></a>transient 关键字 : 瞬态关键字</h3><ul>
<li>被 transient 关键字修饰的成员变量不能被序列化/反序列化。</li>
<li><strong>序列化/反序列化是对对象进行的，因此比对象先进入内存的 static 修饰的成员变量是不可以被序列化/反序列化的</strong></li>
</ul>
<h2 id="4-14-打印流"><a href="#4-14-打印流" class="headerlink" title="4.14 打印流"></a>4.14 打印流</h2><h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><ul>
<li>输出不会抛出 <code>IOException</code> 异常</li>
<li>只管打印，不转换</li>
<li>可改变输出位置</li>
</ul>
<h2 id="4-15-Stream-流"><a href="#4-15-Stream-流" class="headerlink" title="4.15 Stream 流"></a>4.15 Stream 流</h2><h3 id="注意-4"><a href="#注意-4" class="headerlink" title="注意"></a>注意</h3><ul>
<li>JDK 1.8 后才有 Stream 流</li>
<li>Stream 是个通道型接口，只能消费（使用）一次</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><code>static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code> : 用于把流组合到一起</li>
<li><code>static &lt;T&gt; Stream&lt;T&gt; limit(Integer i)</code> : 用于取出流前<code>i</code>个元素重新生成流</li>
<li><code>static &lt;T&gt; Stream&lt;T&gt; skip(Integer i)</code> : 用于去除流前<code>i</code>个元素重新生成流</li>
<li><code>static &lt;T&gt; Long count()</code> : 用于返回流中有几个元素</li>
<li><code>static &lt;T&gt; Stream&lt;T&gt; fliter()</code> : 用于过滤元素</li>
</ul>
<h2 id="4-16-测试"><a href="#4-16-测试" class="headerlink" title="4.16 测试"></a>4.16 测试</h2><h3 id="4-16-1-单元测试-Junit"><a href="#4-16-1-单元测试-Junit" class="headerlink" title="4.16.1 单元测试 Junit"></a>4.16.1 单元测试 <code>Junit</code></h3><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><ul>
<li><code>@Test</code> 标记该方法为测试方法</li>
<li><code>@Before</code> 标记的方法会在所有测试方法运行前运行，一般用于初始化</li>
<li><code>@After</code> 标记的方法会在所有测试方法运行后运行，一般用于关闭资源<h4 id="断言-Assert"><a href="#断言-Assert" class="headerlink" title="断言 Assert"></a>断言 <code>Assert</code></h4></li>
</ul>
<h2 id="4-17-反射"><a href="#4-17-反射" class="headerlink" title="4.17 反射"></a>4.17 反射</h2><h4 id="概念：将类的各个组成部分封装成其他对象，这就是反射机制。"><a href="#概念：将类的各个组成部分封装成其他对象，这就是反射机制。" class="headerlink" title="概念：将类的各个组成部分封装成其他对象，这就是反射机制。"></a>概念：将类的各个组成部分封装成其他对象，这就是反射机制。</h4><h3 id="Class-对象"><a href="#Class-对象" class="headerlink" title="Class 对象"></a>Class 对象</h3><h4 id="常用成员方法-9"><a href="#常用成员方法-9" class="headerlink" title="常用成员方法"></a>常用成员方法</h4><ul>
<li>获取成员变量<ul>
<li><code>Field[] getFields()</code> : 获取被 <code>public</code> 修饰的成员变量</li>
<li><code>Field getField(String name)</code> : 获取变量名为 <code>name</code> 的成员变量</li>
<li><code>Field[] getDeclareFields()</code> : 获取所有的成员变量</li>
</ul>
</li>
<li>获取构造方法<ul>
<li><code>Constructor&lt;?&gt;[] getConstructors()</code></li>
<li><code>Constructor&lt;?&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code></li>
<li><code>Constructor&lt;?&gt;[] getDeclareConstructors()</code></li>
<li><code>Constructor&lt;?&gt; getDeclareConstructor(Class&lt;?&gt;... parameterTypes)</code></li>
</ul>
</li>
<li>获取成员方法<ul>
<li><code>Method&lt;?&gt;[] getMethods()</code></li>
<li><code>Method&lt;?&gt; getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></li>
<li><code>Method&lt;?&gt;[] getDeclareMethods()</code></li>
<li><code>Method&lt;?&gt; getDeclareMethod(String name, Class&lt;?&gt;... parameterTypes)</code></li>
</ul>
</li>
</ul>
<h3 id="Field-对象-成员变量"><a href="#Field-对象-成员变量" class="headerlink" title="Field 对象 (成员变量)"></a>Field 对象 (成员变量)</h3><h4 id="常用成员方法-10"><a href="#常用成员方法-10" class="headerlink" title="常用成员方法"></a>常用成员方法</h4><ul>
<li><code>Object get(Object obj)</code> 获取成员变量的值</li>
<li><code>void set(Object obj, Object obj)</code> 成员变量赋值</li>
<li><code>void setAccessible(boolean b)</code> 设置为 <code>true</code> 则忽略访问权限修饰符的安全检查 (暴力反射)</li>
</ul>
<h3 id="Constructor-对象-构造方法"><a href="#Constructor-对象-构造方法" class="headerlink" title="Constructor 对象 (构造方法)"></a>Constructor 对象 (构造方法)</h3><h4 id="常用成员方法-11"><a href="#常用成员方法-11" class="headerlink" title="常用成员方法"></a>常用成员方法</h4><ul>
<li><code>T newInstance(Object ...)</code> 构造一个对象</li>
<li><code>void setAccessible(boolean b)</code> 设置为 <code>true</code> 则忽略访问权限修饰符的安全检查 (暴力反射)</li>
</ul>
<h3 id="Method-对象-成员方法"><a href="#Method-对象-成员方法" class="headerlink" title="Method 对象 (成员方法)"></a>Method 对象 (成员方法)</h3><h4 id="常用成员方法-12"><a href="#常用成员方法-12" class="headerlink" title="常用成员方法"></a>常用成员方法</h4><ul>
<li><code>void invoke(Object o, Object o)</code> 执行方法</li>
<li><code>void setAccessible(boolean b)</code> 设置为 <code>true</code> 则忽略访问权限修饰符的安全检查 (暴力反射)</li>
<li><code>void getName()</code> 获取方法名称</li>
</ul>
<h2 id="4-18-注解"><a href="#4-18-注解" class="headerlink" title="4.18 注解"></a>4.18 注解</h2><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">PMSRookie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://pmsrookie.github.io/2020/07/15/Java%E5%9F%BA%E7%A1%80-%E9%AB%98%E7%BA%A7/">https://pmsrookie.github.io/2020/07/15/Java%E5%9F%BA%E7%A1%80-%E9%AB%98%E7%BA%A7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://pmsrookie.github.io" target="_blank">PMSRookie</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="/img/cover-img.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"><img class="prev-cover" data-src="/img/cover-img.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络基础</div></div></a></div><div class="next-post pull-right"><a href="/2020/06/29/hexo%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9/"><img class="next-cover" data-src="/img/cover-img.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">hexo主题修改</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(/img/cover-img.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By PMSRookie</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>